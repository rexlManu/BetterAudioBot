// TSLib - A free TeamSpeak 3 and 5 client library
// Copyright (C) 2017  TSLib contributors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the Open Software License v. 3.0
//
// You should have received a copy of the Open Software License along with this
// program. If not, see <https://opensource.org/licenses/OSL-3.0>.
// <auto-generated />

<#@ template debug="true" hostSpecific="true" language="C#" #>
<#@ include file="../Generated/M2BParser.ttinclude" once="true" #>
<#@ include file="../Generated/MessageParser.ttinclude" once="true" #>
<#@ include file="../Generated/BookParser.ttinclude" once="true" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Collections.Generic" #>

using System;
using TSLib.Helper;
using TSLib.Messages;

namespace TSLib.Full
{
	public sealed partial class TsFullClient
	{
		<#
		var genbook = BookDeclarations.Parse(Host.ResolvePath("../Declarations/Book.toml"));
		var genmsg = Messages.Parse(Host.ResolvePath("../Declarations/Messages.toml"));
		var genm2b = M2BDeclarations.Parse(Host.ResolvePath("../Declarations/MessagesToBook.toml"), genmsg, genbook);
		var shared = new HashSet<string> {
			"TextMessage",
			"ClientEnterView",
			"ClientLeftView",
		};
		
		PushIndent("\t\t");
		WriteLine("");

		foreach(var ntfy in OnlyS2C(genmsg.NotifiesSorted))
		{
			Write("public");
			if(shared.Contains(ntfy.name))
				Write(" override");
			WriteLine($" event NotifyEventHandler<{ntfy.name}> On{ntfy.name};");

			Write("public");
			//if(shared.Contains(ntfy.name))
			//	Write(" override");
			WriteLine($" event EventHandler<{ntfy.name}> OnEach{ntfy.name};");
		}
		PopIndent();
		#>

		private void InvokeEvent(LazyNotification lazyNotification)
		{
			var ntf = lazyNotification.Notifications;
			switch (lazyNotification.NotifyType)
			{
			<#
			foreach(var ntfy in OnlyS2C(genmsg.NotifiesSorted))
			{
			#>
			case NotificationType.<#= ntfy.name #>: {
				var ntfc = (<#=ntfy.name #>[])ntf;
				Process<#= ntfy.name #>(ntfc);
				On<#= ntfy.name #>?.Invoke(this, ntfc);
				var ev = OnEach<#= ntfy.name #>;
				var book = Book;
				foreach(var that in ntfc) {<#
					var bookitem = genm2b.rule.FirstOrDefault(x => x.from == ntfy.name);
					if(bookitem != null) {
					#>
					book?.Update<#= ntfy.name #>(that);<# } #>
					ProcessEach<#= ntfy.name #>(that);
					ev?.Invoke(this, that);
				}
				break;
			}
			<#
			}
			#>
			case NotificationType.Unknown:
			default:
				throw Tools.UnhandledDefault(lazyNotification.NotifyType);
			}
		}

		<#
		PushIndent("\t\t");
		foreach(var ntfy in OnlyS2C(genmsg.NotifiesSorted))
		{
			WriteLine($"partial void Process{ntfy.name}({ntfy.name}[] notifies);");
			WriteLine($"partial void ProcessEach{ntfy.name}({ntfy.name} notifies);");
		}
		#>
	}
}