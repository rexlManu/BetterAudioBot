// TSLib - A free TeamSpeak 3 and 5 client library
// Copyright (C) 2017  TSLib contributors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the Open Software License v. 3.0
//
// You should have received a copy of the Open Software License along with this
// program. If not, see <https://opensource.org/licenses/OSL-3.0>.
// <auto-generated />

<#@ template debug="true" hostSpecific="true" language="C#" #>
<#@ include file="M2BParser.ttinclude" once="true" #>
<#@ include file="MessageParser.ttinclude" once="true" #>
<#@ include file="BookParser.ttinclude" once="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#
var genbook = BookDeclarations.Parse(Host.ResolvePath("../Declarations/Book.toml"));
var genmsg = Messages.Parse(Host.ResolvePath("../Declarations/Messages.toml"));
var genm2b = M2BDeclarations.Parse(Host.ResolvePath("../Declarations/MessagesToBook.toml"), genmsg, genbook);
#>
using TSLib.Messages;

<#= ConversionSet #>

namespace TSLib.Full.Book
{
	public partial class Connection
	{
#pragma warning disable IDE0017, CS0472 // Ignore "Object initialization can be simplified", "Something with == and null..."
	<# foreach (var rule in genm2b.rule) {
		var msg = genmsg.NotifiesSorted.First(x => x.name == rule.from);
		var bookItem = genbook.@struct.First(x => x.name == rule.to);
	#>
		public void Update<#= msg.name #>(<#= msg.name #> msg)
		{
			<# var idStr = string.Join(", ", rule.id.Select(x => $"msg.{x}"));

		ClearIndent();
		PushIndent("\t\t\t");
		switch (rule.operation)
		{
		case "add":
		case "update":
			if (rule.operation == "add")
				WriteLine($"var obj = new {rule.to}();");
			else
				WriteLine($@"var obj = Get{rule.to}({idStr});
			if (obj == null) {{
				Log.Warn(""Internal Book protocol error. Update '{msg.name}' has no local object ({{$msg}})"", msg);
				return;
			}}");

			foreach (var prop in rule.properties) {
				void WriteMove(string from, string to) {
					var bookProp = bookItem.properties.FirstOrDefault(x => x.name == to);
					if(bookProp is null) {
						Warn($"No property found: '{to}'");
						return;
					}

					if (prop.operation is null) {
						if (bookProp.mod is null) {
							if (from == "null")
								WriteLine($"obj.{to} = null;");
							else
								WriteLine($"{{ var tmpv = {from}; if (tmpv != null) obj.{to} = ({bookProp.type})tmpv; }}");
						} else if (bookProp.mod == "array") {
							//WriteLine($"obj.{to}.Add({from});");
							if (prop.operation == "add")
								WriteLine($"{{ var tmpa = {from}; if (tmpa != null) obj.{to}.UnionWith(tmpa); }}");
							else
								WriteLine($"{{ var tmpa = {from}; if (tmpa != null) {{ obj.{to}.Clear(); obj.{to}.UnionWith(tmpa); }} }}");
						} else {
							throw new Exception("Unknown mod type: " + bookProp.mod);
						}
					} else if (prop.operation == "add") {
						// Currently hacky; Better check:
						//  [update:single->single]
						//  [add/remove/update:single->array]
						//  [update:array->array]
						WriteLine($"obj.{to}.Add({from});");
					} else if (prop.operation == "remove") {
						// Same here
						WriteLine($"obj.{to}.Remove({from});");
					} else
						throw new Exception("Unknown operation: " + prop.operation);
				}

				if (prop.from != null) {
					WriteMove($"msg.{prop.from}", prop.to);
				} else { /* function */
					if (prop.function == "ReturnNone")
						WriteMove($"null", prop.tolist[0]);
					else if (prop.function == "VoidFun") { /* Do Nothing */ }
					else if(prop.tolist.Length == 0)
						WriteLine($"{prop.function}(msg);");
					else if (prop.tolist.Length == 1)
						WriteMove($"{prop.function}(msg)", prop.tolist[0]);
					else
					{
						WriteLine("{");
						WriteLine($"var tmp = {prop.function}(msg);", prop.to);
						for (int i = 0; i < prop.tolist.Length; i++)
							WriteMove($"tmp.Item{(i + 1)}", prop.tolist[i]);
						WriteLine("}");
					}
				}
			}
			if (rule.operation == "add") {
				WriteLine($"Set{rule.to}(obj{(string.IsNullOrEmpty(idStr) ? "" : (", " + idStr))});");
			}
			break;

		case "remove":#>
			Remove<#=rule.to#>(<#=idStr#>);<#
			break;
		} #>
			Post<#= msg.name #>(msg);
		}

		partial void Post<#= msg.name #>(<#= msg.name #> msg);
	<# } #>
#pragma warning restore IDE0017, CS0472
	}
}