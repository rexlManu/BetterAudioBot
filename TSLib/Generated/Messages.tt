// TSLib - A free TeamSpeak 3 and 5 client library
// Copyright (C) 2017  TSLib contributors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the Open Software License v. 3.0
//
// You should have received a copy of the Open Software License along with this
// program. If not, see <https://opensource.org/licenses/OSL-3.0>.
// <auto-generated />

<#@ template debug="true" hostSpecific="true" language="C#" #>
<#@ include file="MessageParser.ttinclude" once="true" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.IO" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
using System;
using System.Collections.Generic;
using System.Buffers.Text;
using TSLib.Commands;
using TSLib.Helper;

<#= ConversionSet #>

namespace TSLib.Messages
{
<#
var gen = Messages.Parse(Host.ResolvePath("../Declarations/Messages.toml"));

string GenerateDeserializer(Messages.Field fld)
{
	if(fld.isArray)
		return $"{{ if(value.Length == 0) {fld.pretty} = Array.Empty<{fld.type}>(); else {{"
			 + $" var ss = new SpanSplitter<byte>(); ss.First(value, (byte)',');"
			 + $" int cnt = 0; for (int i = 0; i < value.Length; i++) if (value[i] == ',') cnt++;"
			 + $" {fld.pretty} = new {fld.type}[cnt + 1];"
			 + $" for(int i = 0; i < cnt + 1; i++) {{ {GenerateSingleDeserializer(fld, "ss.Trim(value)", fld.pretty + "[i]")} if (i < cnt) value = ss.Next(value); }} }} }}";
	else
		return GenerateSingleDeserializer(fld, "value", fld.pretty);
}

Dictionary<string, string> BackingTypes = new Dictionary<string, string>() {
	{ "Uid", "str" },
	{ "ClientDbId", "u64" },
	{ "ClientId", "u16" },
	{ "ChannelId", "u64" },
	{ "ServerGroupId", "u64" },
	{ "ChannelGroupId", "u64" },
	{ "Codec", "u8" },
	{ "Ts3ErrorCode", "u32" },
	{ "LicenseType", "u16" },
	{ "PermissionId", "u32" },
};

string GenerateSingleDeserializer(Messages.Field fld, string input, string output)
{
	switch (fld.type)
	{
	case "bool":
		return $"{output} = {input}.Length > 0 && {input}[0] != '0';";
	case "i8":
	case "u8":
	case "i16":
	case "u16":
	case "i32":
	case "u32":
	case "i64":
	case "u64":
	case "f32":
	case "f64":
	case "ClientDbId":
	case "ClientId":
	case "ChannelId":
	case "ServerGroupId":
	case "ChannelGroupId":
		if(!BackingTypes.TryGetValue(fld.type, out var backType))
			backType = fld.type;
		return $"{{ if(Utf8Parser.TryParse({input}, out {backType} oval, out _)) {output} = ({fld.type})oval; }}";
	case "DurationSeconds":
		return $"{{ if(Utf8Parser.TryParse({input}, out f64 oval, out _)) {output} = TimeSpan.FromSeconds(oval); }}";
	case "DurationMilliseconds":
		return $"{{ if(Utf8Parser.TryParse({input}, out f64 oval, out _)) {output} = TimeSpan.FromMilliseconds(oval); }}";
	case "DateTime":
		return $"{{ if(Utf8Parser.TryParse({input}, out u32 oval, out _)) {output} = Tools.FromUnix(oval); }}";
	case "str":
	case "Uid":
	case "IpAddr":
		return $"{output} = ({fld.type})TsString.Unescape({input});";
	case "HostMessageMode":
	case "CodecEncryptionMode":
	case "HostBannerMode":
	case "Reason":
	case "ClientType":
	case "TextMessageTargetMode":
	case "GroupType":
	case "GroupNamingMode":
	case "Codec":
	case "Ts3ErrorCode":
	case "LicenseType":
	case "TokenType":
	case "LogLevel":
	case "PluginTargetMode":
	case "PermissionType":
	case "ChannelPermissionHint":
	case "ClientPermissionHint":
		if(!BackingTypes.TryGetValue(fld.type, out backType))
			backType = "i32";
		return $"{{ if(Utf8Parser.TryParse({input}, out {backType} oval, out _)) {output} = ({fld.type})oval; }}";
	case "IconHash":
		return $"{{ if(!{input}.IsEmpty && {input}[0] == (u8)'-') {{ if(Utf8Parser.TryParse({input}, out i32 oval, out _)) {output} = oval; }} else {{ if(Utf8Parser.TryParse({input}, out u64 oval, out _)) {output} = unchecked((i32)oval); }} }}";
	case "PermissionId":
		return $"{{ if(Utf8Parser.TryParse({input}, out u16 oval, out _)) {output} = ser.PermissionTransform.GetName(oval); }}";
	default:
		Warn($"Missing deserializer for {fld.type}");
		return "";
	}
}

foreach(var msg in gen.GetOrderedMsg())
{
	//if(!msg.s2c.Value) continue;
#>
	public sealed partial class <#= msg.name #><#
		bool isNotify = msg.notify != null;
		bool isResponse = msg.response.Value;
		if (isNotify && isResponse) Write(" : INotification, IResponse");
		else if (isNotify) Write(" : INotification");
		else if (isResponse) Write(" : IResponse");
	#>
	{
		<#= isNotify ? "public NotificationType NotifyType { get; } = NotificationType." + msg.name + ";" : "" #>
		<#= isResponse ? "public string ReturnCode { get; set; }" : "" #>
<#
	foreach (var (genField, optional) in msg.attributes.Select(f => gen.GetField(f))) { #>
		public <#= genField.TypeFin(optional) #> <#= genField.pretty #> { get; set; }<# } #>

		public void SetField(string name, ReadOnlySpan<byte> value, Deserializer ser)
		{<#
		if (msg.attributes.Length > 0) { #>
			switch(name)
			{
<#
		foreach (var (genField, optional) in msg.attributes.Select(f => gen.GetField(f))) {
#>
			case "<#= genField.ts #>": <#= GenerateDeserializer(genField) #> break;<#
			}
#>
			<#= isResponse ? ("case \"return_code\": " + GenerateDeserializer(gen.GetField("return_code").fld) + " break;") : "" #>
			}
<#
			} #>
		}

		public void Expand(IMessage[] to, IEnumerable<string> flds)
		{<#
		if (msg.attributes.Length > 0) { #>
			var toc = (<#= msg.name #>[])to;
			foreach (var fld in flds)
			{
				switch(fld)
				{
<#
		foreach (var (genField, optional) in msg.attributes.Select(f => gen.GetField(f))) {
#>
				case "<#= genField.ts #>": foreach(var toi in toc) { toi.<#= genField.pretty #> = <#= genField.pretty #>; } break;<#
				}
#>
				}
			}
<#
			} #>
		}
	}
<# } #>
	public enum NotificationType
	{
		Unknown,<#
	foreach(var ntfy in gen.NotifiesSorted) {
		/*if(!ntfy.s2c.Value) continue;*/ #>
		///<summary><#= ntfy.s2c.Value ? "[S2C] " : "" #><#= ntfy.c2s.Value ? "[C2S] " : "" #>ntfy:<#= ntfy.notify #></summary>
		<#= ntfy.name #>,<#
	}
#>
	}

	public static class MessageHelper
	{
		public static NotificationType GetToClientNotificationType(string name)
		{
			switch(name)
			{<#
	foreach(var ntfy in gen.NotifiesSorted.Where(x => x.s2c.Value)) {#>
			case "<#= ntfy.notify #>": return NotificationType.<#= ntfy.name #>;<#
	}
#>
			default: return NotificationType.Unknown;
			}
		}

		public static NotificationType GetToServerNotificationType(string name)
		{
			switch(name)
			{<#
	foreach(var ntfy in gen.NotifiesSorted.Where(x => x.c2s.Value)) {#>
			case "<#= ntfy.notify #>": return NotificationType.<#= ntfy.name #>;<#
	}
#>
			default: return NotificationType.Unknown;
			}
		}

		public static INotification GenerateNotificationType(NotificationType name)
		{
			switch(name)
			{<#
	foreach(var ntfy in gen.NotifiesSorted)
	{
		/*if(!ntfy.s2c.Value) continue;*/
#>
			case NotificationType.<#= ntfy.name #>: return new <#= ntfy.name #>();<#
	}
#>
			case NotificationType.Unknown:
			default: throw Tools.UnhandledDefault(name);
			}
		}

		public static INotification[] InstatiateNotificationArray(NotificationType name, int len)
		{
			switch(name)
			{<#
	foreach(var ntfy in gen.NotifiesSorted)
	{
		/*if(!ntfy.s2c.Value) continue;*/
#>
			case NotificationType.<#= ntfy.name #>: { var arr = new <#= ntfy.name #>[len]; for (int i = 0; i < len; i++) arr[i] = new <#= ntfy.name #>(); return arr; }<#
	}
#>
			case NotificationType.Unknown:
			default: throw Tools.UnhandledDefault(name);
			}
		}
	}
}