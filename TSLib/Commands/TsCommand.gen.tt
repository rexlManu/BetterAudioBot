// TSLib - A free TeamSpeak 3 and 5 client library
// Copyright (C) 2017  TSLib contributors
//
// This program is free software: you can redistribute it and/or modify
// it under the terms of the Open Software License v. 3.0
//
// You should have received a copy of the Open Software License along with this
// program. If not, see <https://opensource.org/licenses/OSL-3.0>.
// <auto-generated />
<#@ template debug="false" hostspecific="true" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>

<#
// "TimeSpan" (Currently removed, as it is too ambiguous)
var types = new [] {"bool", "sbyte", "byte", "short", "ushort", "int", "uint", "long", "ulong", "float", "double", "string", "DateTime" };
var aliasTypes = new [] { "Uid",  "ClientDbId", "ClientId", "ChannelId", "ServerGroupId", "ChannelGroupId"};
var classTypes = new [] { "string" };
#>

using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Linq;

namespace TSLib.Commands
{
	partial class TsCommand
	{
<#
foreach (var type in types.Concat(aliasTypes)) { 
	if (classTypes.Contains(type)) { #>
		[DebuggerStepThrough] public TsCommand Add(string key, <#= type #> value) { if(value != null) Add(new CommandParameter(key, value)); return this; }
<# } else { #>
		[DebuggerStepThrough] public TsCommand Add(string key, <#= type #>? value) { if(value.HasValue) return Add(key, value.Value); return this; }
		[DebuggerStepThrough] public TsCommand Add(string key, <#= type #> value) => Add(new CommandParameter(key, value));
<# } #>
		[DebuggerStepThrough] public TsCommand Add(string key, IEnumerable<<#= type #>> value) => Add(new CommandMultiParameter(key, value));
<# } #>
	}

	partial class CommandParameter
	{
<# foreach (var type in types.Concat(aliasTypes)) {
	var value = aliasTypes.Contains(type) ? "value.Value" : "value";
	#>
		[DebuggerStepThrough] public CommandParameter(string key, <#= type #> value) { Key = key; Value = Serialize(<#= value #>); }
<# } #>
	}

	partial class CommandMultiParameter
	{
<#
foreach (var type in types.Concat(aliasTypes)) { 
	if (aliasTypes.Contains(type)) { #>
		[DebuggerStepThrough] public CommandMultiParameter(string key, IEnumerable<<#= type #>> value) { Key = key; Values = value.Select(v => CommandParameter.Serialize(v.Value)).ToArray(); }
<# } else { #>
		[DebuggerStepThrough] public CommandMultiParameter(string key, IEnumerable<<#= type #>> value) { Key = key; Values = value.Select(CommandParameter.Serialize).ToArray(); }
<#
	}
}
#>
	}
}